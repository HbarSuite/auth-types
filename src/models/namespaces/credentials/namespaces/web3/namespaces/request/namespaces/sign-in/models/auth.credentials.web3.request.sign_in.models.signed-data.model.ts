import { ApiProperty } from '@hsuite/nestjs-swagger'
import { IAuth } from '../../../../../../../../../../interfaces/auth.namespace'
import { _SignedPayload } from './auth.credentials.web3.request.sign_in.models.signed-payload.model'

/**
 * Class representing the signed data for Web3 sign-in process.
 * 
 * @class _SignedData
 * @implements {IAuth.ICredentials.IWeb3.IRequest.ISignin.ISignedData}
 * @namespace Auth.Credentials.Web3.Request.Signin
 * @description Defines the structure and validation of signed data used in the Web3 sign-in process.
 * This class handles both the server-signed payload and user signature required for authentication.
 * @since 2.0.0
 * @category Authentication
 * @module Auth.Credentials.Web3
 * @public
 * 
 * @property {IAuth.ICredentials.IWeb3.IRequest.ISignin.ISignedPayload} signedPayload - The signed payload containing server signature and message
 * @property {Uint8Array} userSignature - The user's cryptographic signature proving account ownership
 * 
 * @throws {Error} Will throw if signedPayload is not a valid object
 * @throws {Error} Will throw if userSignature is not a non-empty Uint8Array
 * 
 * @example
 * const signedData = new _SignedData({
 *   signedPayload: {
 *     signature: new Uint8Array([1,2,3]),
 *     payload: "Message to sign"
 *   },
 *   userSignature: new Uint8Array([4,5,6])
 * });
 */
export class _SignedData implements IAuth.ICredentials.IWeb3.IRequest.ISignin.ISignedData {
    /**
     * The signed payload containing the server signature and original authentication payload.
     * Must be a valid object implementing the ISignedPayload interface.
     * 
     * @type {IAuth.ICredentials.IWeb3.IRequest.ISignin.ISignedPayload}
     * @memberof _SignedData
     * @public
     * @since 2.0.0
     * @description Contains both the server's cryptographic signature and the original message payload that was signed.
     * Used to verify the authenticity of the sign-in request.
     * 
     * @throws {Error} Will throw if signedPayload is not a valid object
     * 
     * @example
     * signedPayload = {
     *   signature: new Uint8Array([1,2,3]),
     *   payload: "Message to sign"
     * }
     */
    @ApiProperty({
        description: 'The signed payload containing the server signature and original authentication payload',
        type: () => _SignedPayload
    })
    signedPayload: IAuth.ICredentials.IWeb3.IRequest.ISignin.ISignedPayload

    /**
     * The signature generated by the user to prove ownership of the account.
     * Must be a non-empty Uint8Array containing valid signature bytes.
     * 
     * @type {Uint8Array}
     * @memberof _SignedData
     * @public
     * @since 2.0.0
     * @description A cryptographic signature created by the user's wallet/private key to prove they control the account.
     * The signature is generated by signing the server's signed payload.
     * 
     * @throws {Error} Will throw if userSignature is not a Uint8Array
     * @throws {Error} Will throw if userSignature is empty
     * 
     * @example
     * userSignature = new Uint8Array([1,2,3,4,5])
     */
    @ApiProperty({
        description: 'The signature generated by the user to prove ownership of the account',
        type: () => Uint8Array,
        isArray: true
    })
    userSignature: Uint8Array

    /**
     * Creates an instance of _SignedData.
     * Validates and initializes the signed payload and user signature.
     * 
     * @constructor
     * @param {IAuth.ICredentials.IWeb3.IRequest.ISignin.ISignedData} signedData - The signed data object containing both signatures
     * @throws {Error} Will throw if signedPayload is not a valid object implementing ISignedPayload
     * @throws {Error} Will throw if userSignature is not a non-empty Uint8Array
     * @memberof _SignedData
     * @since 2.0.0
     * @description Validates and initializes a new signed data instance containing both the server's signed payload
     * and the user's signature. Performs type checking and validation on both signatures.
     * 
     * @example
     * const signedData = new _SignedData({
     *   signedPayload: {
     *     signature: new Uint8Array([1,2,3]),
     *     payload: "Message to sign"
     *   },
     *   userSignature: new Uint8Array([4,5,6])
     * });
     */
    constructor(signedData: IAuth.ICredentials.IWeb3.IRequest.ISignin.ISignedData) {
        // Validate signed payload is a valid object
        if (!signedData.signedPayload || typeof signedData.signedPayload !== 'object') {
            throw new Error('Signed payload must be a valid object')
        }
        this.signedPayload = signedData.signedPayload

        // Validate user signature is a non-empty Uint8Array
        if (!(signedData.userSignature instanceof Uint8Array)) {
            throw new Error('User signature must be a Uint8Array')
        }
        if (signedData.userSignature.length === 0) {
            throw new Error('User signature cannot be empty')
        }        
        this.userSignature = signedData.userSignature
    }
}